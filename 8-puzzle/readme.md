# <8-puzzle 알고리즘>

### 일반적인 8-Puzzle
  3×3 보드에서 한 칸(0)이 비어 있고 나머지 8개의 숫자를 슬라이딩하여 목표 상태를 만드는 문제
### 2×5 퍼즐
  2행×5열, 즉 총 10칸 중 하나가 비어 있고(0), 나머지 9개의 숫자를 슬라이딩하여 목표 상태를 만드는 문제

---

## 1. 문제 개요

- **퍼즐 형태**: 2행 5열 (총 10칸)
- **초기 상태** (`"2194705368"`)
| 2 | 1 | 9 | 4 | 7 |
|---|---|---|---|---|
| 0 | 5 | 3 | 6 | 8 |

- **목표 상태** (`"0123456789"`)
| 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
| 5 | 6 | 7 | 8 | 9 |


## 2. BFS (너비 우선 탐색)

### 2.1 개념
- 시작 상태에서 **가장 가까운**(깊이 1) 상태들을 모두 방문한 뒤, 그 다음 깊이(깊이 2)로 넘어가는 방식으로 탐색합니다.
- 보통 **큐(Queue)** 자료구조를 사용하여, 먼저 들어온 상태를 먼저 확장(First-In-First-Out)하는 형태입니다.
- 이동 비용이 모두 동일하다면, **최단 거리(최소 이동 횟수) 경로**를 보장합니다.

### 2.2 장점
1. **최단 해 보장**  
   - 퍼즐에서 한 번의 슬라이딩 비용을 1로 볼 때, BFS는 목표 상태를 **가장 적은 이동 횟수**로 처음 발견했을 때 그 경로가 최단 해입니다.

2. **직관적이고 단순한 구현**  
   - 상태를 큐에 넣고, 꺼내면서 이웃 상태를 다시 큐에 넣는 과정을 반복하기만 하면 됩니다.

### 2.3 단점
1. **메모리 사용량이 매우 큼**  
   - 2×5 퍼즐의 상태 공간은 최대 10! (3,628,800) 가지에 이를 수 있습니다.  
   - BFS는 확장 범위가 넓어, 많은 상태가 **큐에 한꺼번에** 저장될 수 있으므로 메모리가 크게 소모됩니다.

2. **탐색 시간 증가**  
   - 목표 상태가 깊이 d에 있을 때, 그 전 단계(깊이 d-1)까지의 모든 상태를 확장해야 하므로, 상태 공간이 큰 퍼즐에선 시간이 오래 걸릴 수 있습니다.

---

## 3. DFS (깊이 우선 탐색)

### 3.1 개념
- 시작 상태에서 **가장 깊이** 내려갈 수 있는 경로를 우선적으로 탐색하고, 막히면(더 이상 확장할 수 없으면) 백트래킹을 통해 다른 가지로 이동합니다.
- 보통 **스택(Stack)** 이나 **재귀 함수**로 구현합니다.
- 최단 경로를 반드시 찾는 방식은 아니며, 깊이가 매우 깊어지거나 순환 구조가 있을 경우 비효율적이 될 수 있습니다.

### 3.2 장점
1. **상대적으로 메모리 사용이 적음**  
   - 스택(또는 재귀 호출 스택)에 저장되는 경로만 추적하므로, BFS보다 메모리 부담이 덜한 편입니다.

2. **구현 간단**  
   - 재귀 함수를 사용하면 직관적으로 작성 가능하며, 구조가 단순합니다.

### 3.3 단점
1. **최단 해 보장 불가**  
   - 깊은 곳부터 탐색하므로, 해가 얕은 곳(적은 이동 횟수)에 있어도 발견이 늦어질 수 있습니다.

2. **상태 공간이 클 때 시간 소요가 커질 수 있음**  
   - 퍼즐에서 특정 경로로 계속 깊게 들어가면, 막힌 뒤에야 되돌아오므로(백트래킹), 많은 시간을 허비하게 됩니다.

---

## 4. A* (에이스타 탐색)

### 4.1 개념
- `f(n) = g(n) + h(n)` 형태로 **우선순위 큐**를 이용해, **가장 유망한**(f 값이 작은) 상태부터 확장해 나가는 휴리스틱 기반 탐색 알고리즘입니다.
  - `g(n)`: 시작 상태에서 현재 상태 n까지의 실제 비용(슬라이딩 횟수 등)
  - `h(n)`: 목표 상태까지의 **추정 비용**(휴리스틱). 2×5 퍼즐에서는 맨해튼 거리의 합 등을 자주 사용합니다.
- **휴리스틱**이 어드미시블(admissible)하면, **최적 해(최단 경로)**를 찾을 수 있다는 중요한 이론적 보장이 있습니다.

### 4.2 장점
1. **최단 해 탐색 효율 높음**  
   - BFS는 목표까지의 모든 경로를 동일하게 확장하지만, A*는 “목표에 더 가깝다고 추정”되는 상태를 우선 처리하므로, **탐색 공간**이 크게 줄어듭니다.

2. **유연성**  
   - 휴리스틱 함수를 개선(예: 맨해튼 거리 대신 패턴 데이터베이스 등)하면, 탐색 속도를 더욱 향상시킬 수 있습니다.

### 4.3 단점
1. **휴리스틱 설계 필요**  
   - 문제 특성에 맞는 휴리스틱을 정교하게 만들어야 성능이 제대로 발휘됩니다.
   - 휴리스틱이 잘못(과대추정)되면 최적 해 보장이 깨질 수 있습니다.

2. **구현 복잡**  
   - 우선순위 큐로 f(n) 값을 관리하고, 방문 상태의 g 비용 갱신 로직 등이 BFS/DFS보다 어렵습니다.

---

### 종합 비교

| 알고리즘 | 최단 해 보장 | 메모리 사용 | 탐색 효율 | 휴리스틱 필요 | 구현 난이도 |
|:-------:|:---------:|:---------:|:------:|:---------:|:-------:|
| **BFS** | O (동일 비용) | 큼       | 폭발적 증가 가능 | X | 낮음 |
| **DFS** | X           | 작음(상대) | 깊이 우선으로 비효율 | X | 낮음 |
| **A\*** | O (조건 충족) | 중간~큼   | 휴리스틱이 좋으면 빠름 | O | 높음 |

- **BFS**: 최단 해 보장, 그러나 **상태 공간이 커지면** 메모리와 시간 모두 부담  
- **DFS**: 구현과 메모리 사용이 간단하지만, 최단 해 보장이 없어 대규모 퍼즐엔 비효율적  
- **A\***: 휴리스틱 설계가 필요하지만, **대규모 퍼즐에서 최적 경로를 찾는** 데 가장 효율적  

---


